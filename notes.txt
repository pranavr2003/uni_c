LEC 26/01/21

Preprocessors: 

- Header file inclusion (like stdio.h)
- Macro Expansion (#define) - Replaces
- Comment Removal (To ignore comments that are to be ignored)

Variables: 

- Container
- Can hold any datatype
- Scope - Global or local
- HAS to be declared and/or initialized

Constants (Cannot be declared again and remain the same), Keywords 
(cannot be used as var or func names etc.), Identifiers 
(help identify a var/func - naming appropriately for readibility)

Datatypes: int, float, char, double, string, void etc.

%f - float
%d - int
%c - char
%s - str

Arithmetic Operators - +,-,/,*,%, +=,-=,/=,%=,*=

-------------------------------------------------------------------------

LEC 27/01/21

Operators Precedence: 

- 7 + 3*2 = 13
- C follows BODMAS

Logical Operators: 

- Result is only TRUE or FALSE
- && (and) - TRUE iff both are true
- || (or) - TRUE if either are true
- ! (is not)

Functions: 

return_type func_name(parameters) { 

//content

}


Func Declaration: 

return_type func_name(parameters);

User  Input: 

scanf("%d", &radius); - Get radius input

---------------------------------------------------------------------------

LEC 01/02/22

Conditional Statements: 

int num = 6;

if ((num%2) == 0) {

printf("%d is an even number", num);

}

else {

printf("%d is an odd number", num);

}

------------------------------------------------------------------------

LEC 15/02/21

Pointers

&num1 (In scanf) is actually a memory address. The '&' 
actually gives the memory address of num1. 

Here's some code: 

```
int num1;
char name[10];

printf("Address of num1: %p\n", &num1);
printf("Address of name: %p\n", &name);
```
When the program runs, while it will not print the 
value of the variables (since they're only initialized), 
it WILL print the memory address - like 0xfff1cd96950
Mem add is always in hexadecimal. hex. 

%p - Datatype for pointers

Accessing Memory Locations

Since a pointer is a datatype that only hold mem addresses, 
you cannot assign anything to it. 

Hence, it has to be a mem ad 
associated with a variable already decleared elsewhere

```
int age = 10;
double gpa = 8.9;
char grade = 'A';

int* pAge;     // pointer to integer variable
double* pGpa;
char* pGrade;
```
Here, you're declaring the pointer variable to age. 
Conevntion: `type *var-name;`

i.e; A pointer is a var whose value is the address 
of another variable. 

To assign the mem address (we declared in the most recent 
piece of code)

```
pAge = &age;     // pAge gets the mem add of age and 
                 // assigns to pAge
pGpa = &gpa;
pGrade = &grade;

printf("%p %p %p", pAge, pGpa, pGrade);
// prints the mem addresses of age, gpa and grade
```

```
int num1 = 5;
int *pnum1;
pnum1 = &num1;

*pnum1 = 1;   //now num1 = *pnum1 = 1
```

Here, changing the value of *pnum1 changes the value of the variable it 
points to. Doesn't change the mem add., of course. 
The value of *pnum is called the context of pointer pnum. 

---------------------------------------------------------------------------------

LEC 17/02/2022

Creating an external file:

```
FILE *fpointer = fopen("test.txt", "w");

// do stuff
fprintf(fpointer, "Something to write");    // Prints into the file.

fclose(fpointer);
```

FILE *fpointer - File pointer that points to a file. 

```
char line[255];
FILE *fpointer = fopen(...);

fgets(line, 255, fpointer);    // takes str input and writes to file
printf("%s", line);
```

Number System

Decimal - Base 10, No. Range 0-9
Binary - Base 2, Number Range 1, 2
Octal - Base 8, No Range 0-7
Hexadecimal - Base 16, No. Range 0-9, A-F

----------------------------------------------------------------------------------------------

LEC 22/02/22

See Logic Gates

Ports

ATmega 2560 is a 100 pin micro-controller
-> 86 pins can be used as Input/Output pins
-> Pins are grouped together and are called Ports
ATmega 2560 has ten 8-bit ports
-> Port x; x = A to F and H, J, K

Each Port has three associated registers with it:
> DDRx x = A to H and J, K, L
> PORTx x = A to H and J, K, L
> PINx x = A to H and J, K, L

----------------------------------------------------------------------

LEC 3/3/22

Sensors on Firebird ATMega 2560

1. Sharp IR Sensors (5 of them on the Firebird)  (Google working of sharp sensors)
    > Transmitter: IR LED
    > Receiver: CCD Array
2. IR Proximity Sensors (8 of them on the Firebird)
    > Transmitter: IR LED
    > Receiver: Photo-Transistor
3. White Line Sensors (1 on the Firebird)
    > Transmitter: Red LED
    > Receiver: Photo-Transistor
4. Position Encoder (2 on the Firebird)
    > Transmitter: IR Transmitter
    > Receiver: Photo-Transistor
5. Infrard TSOP Receiver (1 in number)
    > Receiver: Photo-Transistor
6. Actuators - Two 60 RPM DC Geared Motors
7. Servo Motors

Powering the bot - Battery, Auxillary Power (12V 1A adapter)

Communication

-> Wired Communication
    Between robot and system (XUSB; RS-232 Serial; USB-to Serial)
-> Wireless Communication
    Between robot and system and robot and robot
    X-bee (pronounced "zig-bee") based on IEEE 802.15.4 protocol
-> Infrard Remote

-------------------------------------------------------------------------

LEC 7/3/22

Ports

ATmega 2560 is a 100 pin micro-controller
-> 86 pins can be used as Input/Output pins
-> Pins are grouped together and are called Ports
ATmega 2560 has ten 8-bit ports
-> Port x; x = A to F and H, J, K

Each Port has three associated registers with it:
> DDRx x = A to H and J, K, L
> PORTx x = A to H and J, K, L
> PINx x = A to H and J, K, L

Bits go from 0 to 7

DDRx - Data Direction Register - To define port pins as I/O
DDRx bit = 0   // portx pin is defined as input
DDRx bit = 1   // portx pin is defined as output

0100 1010   (bits 6, 3, 1 as output)

DDRB = 0x4A

Hexadecimal - Base 16, No. Range 0-9, A-F

PINx - To read data present on port pins

PORTx - To activate/deactivate pull-up resistor on a bit
PORTx bit = 1
PORTx bit = 0

Case 1: Port X is input
Case 2: Port x is output

8 bits - forst 4 (0 to 3) is lower nibble and the next four is upper nibble

--------------------------------------------------------------------------------------------

LEC 10/3/22

ATMega 2560 - Port C, Pin 3

---------------------------------------------------------------------------------------------

{
Buzzer- Port C, Pin 3
BarLED- Port J, Pins 0-7
Interrupt Switch- Port E, Pin 7
White line sensor- Port F
&- Stop, Turn Off, Reset, Input, Disable, Low, Deactivate pull-up - 0
|- Start ,Turn On, Set, Output, Enable, High, Activate pull-up - 1
ADC Conversion- Port K, F
}

Input devices - switch, sensor
Ouput/Interfaccing devices - 16x2 BarLED, LCD, Buzzer

Port G - 6-bit port

DDRx - Set the ports pins as input or output.
DDRx bit val 0 -> Portx pin is defined as input
bit val 1 -> Portx pin is output

Nibble is a group of four bits. Represented in hexadecimal.


Lower nibble - Bit 0-3
Upper nibble - Bit 4-7

DDRB = 1111 0000
DDRB = 0xF0

PINx - Read data present on portx pins
It saves the value of the register in a variable

When Port x is defined as output:
Purpose - Send data on Port x pins

 DDRA = 1111 1111
 DDRA = 0xFF (setting port d as output - all 1s)
 PORTA = 0xFF (seetting logic high on all bits, 0x00 will turn off all LEDs)
 
When Port x is defined as input:
Purpose - Activate/deactivate pull-up resistor
It is used to assure tht the input to the pin is maintained to a desired logic level even if no devices are conected to it. 
This is done to prevent external noise and erred data. 
  When switch is closed, pin is connected to the ground.
  When it is open, pin is connected to VCC and will read logic 1. 
  
  PORTx bit = 1 will ativate pull-up resistor on Portx pin
  else:
    0
  PORTA = 0xFF will activate pull-up resistors on all pins of PORTA.

Masking

OR - To SET a particular bit
AND - Reset bit
EXOR - Toggle bit

Truth Tables

OR (setting - |) - 0|0 = 0, else: 1
AND (resetting - &) - 1|1 = 1, else: 0

Q: Register has data 0x87
Reset only pin 2, keeping others intact

A: 
reg_no = 1000 0111
reg_no &= 0xFB (or) reg_no &= ~(1 << 2)
-> 1000 0111
       &
   1111 1011 
   
   = 1111 1001 (output)
   
   Since 1 & 1 is 1, else 0
